"""
 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков. Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
 Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
 ● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
 ● написать 3 варианта кода (один у вас уже есть);
 ● проанализировать 3 варианта и выбрать оптимальный;
 ● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
 ● написать общий вывод: какой из трёх вариантов лучше и почему.
 Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, а проявили творчество, фантазию и создали универсальный код для замера памяти.
"""
import sys
from collections import deque
EXAMPLE_INPUT = 3486
spam = 0  # В связи с тем, что замер памяти происходит в рекурсии,
          # я не смог всунуть счётчик внутри рекурсии, пришлось делать global

"""
 lesson 2, task 3. Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
 Например, если введено число 3486, надо вывести 6843.
"""


# Изначальное
def revers(num_in, tmp=None, cnt=None) -> int:
    if cnt == 1:
        return str(tmp), cnt, num_in  # cnt, num - для оценки памяти
    elif cnt is None:
        cnt = len(str(num_in))
    else:
        cnt -= 1
    tmp = num_in % 10 if tmp is None else int(str(tmp) + str(num_in % 10))
    return revers(num_in // 10, tmp, cnt)


# Улучшенное
def revers_better(num_in) -> int:
    num = list(str(num_in))
    num_ = list(str(num_in))  # Для оценки
    eggs = 0
    for i, n in enumerate(num, 1):
        eggs += int(n) * 10 ** i
    else:
        eggs = eggs // 10
    return eggs, num_, i  # num_, i - для оценки памяти


# Альтернатива
def revers_another(num_in) -> int:
    num = deque(num_in)
    num_ = deque(num_in)  # Для оценки
    eggs = 0
    for i in range(len(num)):
        eggs += int(num.popleft()) * 10 ** i
    return eggs, num_, i  # num_ - для оценки памяти


# Пример с урока
def show(*args):
    global spam
    for obj in args:
        print(f'{type(obj)=}\t{sys.getsizeof(obj)=}\t{obj=}')
        spam += sys.getsizeof(obj)
        if hasattr(obj, '__iter__'):
            if hasattr(obj, 'items'):
                for key, value in obj.items:
                    show(key)
                    show(value)
            elif not isinstance(obj, str):
                for item in obj:
                    show(item)


a = revers(EXAMPLE_INPUT)
b = revers_better(EXAMPLE_INPUT)
c = revers_another(str(EXAMPLE_INPUT))  # string, т.к. изначально был print, считаю это допустимым отступлением

# Python 3.8.5, UBUNTU 20.04, 64 bit
show(a)   # Рассмотр строк
print(f'Объём затраченной памяти = {spam - sys.getsizeof(a)}')  # Объём затраченной памяти = 80
spam = 0  # Обнуляем переменную для замеров
show(b)   # Список
print(f'Объём затраченной памяти = {spam - sys.getsizeof(b)}')  # Объём затраченной памяти = 344
spam = 0  # Обнуляем переменную для замеров
show(c)   # Очередь
print(f'Объём затраченной памяти = {spam - sys.getsizeof(c)}')  # Объём затраченной памяти = 880

"""
    Тезультаты показывают:
    deque > list > string
    
    Получается, что ОЧЕРЕДЬ являясь более быстрым способом доступа, но
    замимает больше памяти на служебную информацию. Видимо из-за того,
    что каждый блок памяти хранит инфоомацию о следующем и предыдущем блоке.
    
    СТРОКИ являясь более частным случаем СПИСКА, и менее затратны по памяти.
    Четыре строки по одному символу (пример списка), занимают меньше, чем одна СТРОКА
    с четыремя символами (как и список с четыремя объектами по одному символу).
    
    Второй вариант всё же самый оптимальный, т.к. в первом есть затратная канкатенация строк,
    которая является не оптимальной, для данной задачи. И при замерах памяти внутри цикла я считаю рекурсия себя
    показала бы хуже из-за стека.
"""
